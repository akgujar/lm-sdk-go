// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AlertResponse alert response
//
// swagger:model AlertResponse
type AlertResponse struct {

	// The active SDT, if one exists
	// Read Only: true
	SDT interface{} `json:"SDT,omitempty"`

	// The comment submitted with the acknowledgement
	// Read Only: true
	AckComment string `json:"ackComment,omitempty"`

	// Whether or not the alert has been acknowledged
	// Read Only: true
	Acked *bool `json:"acked,omitempty"`

	// The user that acknowledged the alert
	// Read Only: true
	AckedBy string `json:"ackedBy,omitempty"`

	// The time (in epoch format) that the alert was acknowledged
	// Read Only: true
	AckedEpoch int64 `json:"ackedEpoch,omitempty"`

	// Specifies whether alert is dynamic threshold based or not
	// Read Only: true
	AdAlert *bool `json:"adAlert,omitempty"`

	// The description for dynamic threshold based alert
	// Read Only: true
	AdAlertDesc string `json:"adAlertDesc,omitempty"`

	// The value that triggered the alert
	// Read Only: true
	AlertValue string `json:"alertValue,omitempty"`

	// Indicates the anomaly alert, value can be true/false/null. If alert value lies within confidence band then false, otherwise true. If confidence band is not available then value will be null.
	// Read Only: true
	Anomaly *bool `json:"anomaly,omitempty"`

	// The escalation chain the alert was routed to
	// Read Only: true
	Chain string `json:"chain,omitempty"`

	// The id of the escalation chain the alert was routed to
	// Read Only: true
	ChainID int32 `json:"chainId,omitempty"`

	// The value that cleared the alert
	// Read Only: true
	ClearValue string `json:"clearValue,omitempty"`

	// Whether or not the alert has cleared
	// Read Only: true
	Cleared *bool `json:"cleared,omitempty"`

	// The id of the datapoint in alert
	// Read Only: true
	DataPointID int32 `json:"dataPointId,omitempty"`

	// The name of the datapoint in alert
	// Read Only: true
	DataPointName string `json:"dataPointName,omitempty"`

	// The dependency role
	// Read Only: true
	DependencyRole string `json:"dependencyRole,omitempty"`

	// The dependency routing state
	// Read Only: true
	DependencyRoutingState string `json:"dependencyRoutingState,omitempty"`

	// Indicates dynamic threshold alert generation setting. Expression is comma separated
	// 0 denotes OFF, 1 denotes ON, -1 denotes INVALID
	// 1,0,1 =   warn : ON     error: OFF   critical: ON
	// Empty value on this parameter means : 0,0,0
	// Read Only: true
	EnableAnomalyAlertGeneration string `json:"enableAnomalyAlertGeneration,omitempty"`

	// Indicates anomaly detection alert suppression setting, expression is comma separated
	// 0 denotes OFF, 1 denotes ON, -1 denotes INVALID
	// 1,0,1 =   warn : ON     error: OFF   critical: ON
	// Empty value on this parameter means : 0,0,0
	// Read Only: true
	EnableAnomalyAlertSuppression string `json:"enableAnomalyAlertSuppression,omitempty"`

	// The time (in epoch format) that the alert ended
	// Read Only: true
	EndEpoch int64 `json:"endEpoch,omitempty"`

	// The alert id
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The description of the instance in alert
	// Read Only: true
	InstanceDescription string `json:"instanceDescription,omitempty"`

	// The id of the instance in alert
	// Read Only: true
	InstanceID int32 `json:"instanceId,omitempty"`

	// The name of the instance in alert
	// Read Only: true
	InstanceName string `json:"instanceName,omitempty"`

	// The internal id for the alert
	// Read Only: true
	InternalID string `json:"internalId,omitempty"`

	// Information about the groups the object is a member of
	// Read Only: true
	MonitorObjectGroups interface{} `json:"monitorObjectGroups,omitempty"`

	// The id of the object that the alert is associated with
	// Read Only: true
	MonitorObjectID int32 `json:"monitorObjectId,omitempty"`

	// The name of the object that the alert is associated with
	// Read Only: true
	MonitorObjectName string `json:"monitorObjectName,omitempty"`

	// monitor object type
	// Read Only: true
	MonitorObjectType string `json:"monitorObjectType,omitempty"`

	// The next recipient in the escalation chain for this alert
	// Read Only: true
	NextRecipient int32 `json:"nextRecipient,omitempty"`

	// The recipients that have received the alert
	// Read Only: true
	ReceivedList string `json:"receivedList,omitempty"`

	// The device specific LogicModule Id
	// Read Only: true
	ResourceID int32 `json:"resourceId,omitempty"`

	// The id of the datasource in alert
	// Read Only: true
	ResourceTemplateID int32 `json:"resourceTemplateId,omitempty"`

	// The name of the datasource in alert
	// Read Only: true
	ResourceTemplateName string `json:"resourceTemplateName,omitempty"`

	// The type of the logicmodule in alert
	// Read Only: true
	ResourceTemplateType string `json:"resourceTemplateType,omitempty"`

	// The rule the alert matches
	// Read Only: true
	Rule string `json:"rule,omitempty"`

	// The id of the rule the alert matches
	// Read Only: true
	RuleID int32 `json:"ruleId,omitempty"`

	// It specifies if the SDT is set for an active alert or not. However, the sdted is set to false for cleared alert as you cannot apply SDT to a cleared alert.
	// Read Only: true
	Sdted *bool `json:"sdted,omitempty"`

	// The alert severity, where 2=warning, 3=error and 4=critical
	// Read Only: true
	Severity int32 `json:"severity,omitempty"`

	// The time (in epoch format) that the alert started
	// Read Only: true
	StartEpoch int64 `json:"startEpoch,omitempty"`

	// The id of the sub time based chain
	// Read Only: true
	SubChainID int32 `json:"subChainId,omitempty"`

	// The description for suppressed alert
	// Read Only: true
	SuppressDesc string `json:"suppressDesc,omitempty"`

	// The component (For example: SDT, HostClusterAlert) which suppressed the alert
	// Read Only: true
	Suppressor string `json:"suppressor,omitempty"`

	// Tenant to which this alert belongs to.
	// Read Only: true
	Tenant string `json:"tenant,omitempty"`

	// The threshold associated with the object in alert
	// Read Only: true
	Threshold string `json:"threshold,omitempty"`

	// The type of alert
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this alert response
func (m *AlertResponse) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this alert response based on the context it is used
func (m *AlertResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAckComment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAcked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAckedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAckedEpoch(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdAlert(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdAlertDesc(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertValue(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAnomaly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChainID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClearValue(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCleared(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataPointID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataPointName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDependencyRole(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDependencyRoutingState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnableAnomalyAlertGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnableAnomalyAlertSuppression(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEndEpoch(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstanceDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstanceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstanceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInternalID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMonitorObjectID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMonitorObjectName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMonitorObjectType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNextRecipient(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReceivedList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceTemplateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceTemplateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceTemplateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRuleID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSdted(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSeverity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartEpoch(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubChainID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuppressDesc(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuppressor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenant(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThreshold(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AlertResponse) contextValidateAckComment(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ackComment", "body", string(m.AckComment)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAcked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "acked", "body", m.Acked); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAckedBy(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ackedBy", "body", string(m.AckedBy)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAckedEpoch(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ackedEpoch", "body", int64(m.AckedEpoch)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAdAlert(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "adAlert", "body", m.AdAlert); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAdAlertDesc(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "adAlertDesc", "body", string(m.AdAlertDesc)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAlertValue(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertValue", "body", string(m.AlertValue)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateAnomaly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anomaly", "body", m.Anomaly); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateChain(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "chain", "body", string(m.Chain)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateChainID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "chainId", "body", int32(m.ChainID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateClearValue(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clearValue", "body", string(m.ClearValue)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateCleared(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cleared", "body", m.Cleared); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateDataPointID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "dataPointId", "body", int32(m.DataPointID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateDataPointName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "dataPointName", "body", string(m.DataPointName)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateDependencyRole(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "dependencyRole", "body", string(m.DependencyRole)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateDependencyRoutingState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "dependencyRoutingState", "body", string(m.DependencyRoutingState)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateEnableAnomalyAlertGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "enableAnomalyAlertGeneration", "body", string(m.EnableAnomalyAlertGeneration)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateEnableAnomalyAlertSuppression(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "enableAnomalyAlertSuppression", "body", string(m.EnableAnomalyAlertSuppression)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateEndEpoch(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "endEpoch", "body", int64(m.EndEpoch)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateInstanceDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instanceDescription", "body", string(m.InstanceDescription)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateInstanceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instanceId", "body", int32(m.InstanceID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateInstanceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instanceName", "body", string(m.InstanceName)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateInternalID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "internalId", "body", string(m.InternalID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateMonitorObjectID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "monitorObjectId", "body", int32(m.MonitorObjectID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateMonitorObjectName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "monitorObjectName", "body", string(m.MonitorObjectName)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateMonitorObjectType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "monitorObjectType", "body", string(m.MonitorObjectType)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateNextRecipient(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nextRecipient", "body", int32(m.NextRecipient)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateReceivedList(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "receivedList", "body", string(m.ReceivedList)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateResourceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "resourceId", "body", int32(m.ResourceID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateResourceTemplateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "resourceTemplateId", "body", int32(m.ResourceTemplateID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateResourceTemplateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "resourceTemplateName", "body", string(m.ResourceTemplateName)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateResourceTemplateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "resourceTemplateType", "body", string(m.ResourceTemplateType)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateRule(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rule", "body", string(m.Rule)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateRuleID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ruleId", "body", int32(m.RuleID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateSdted(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sdted", "body", m.Sdted); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateSeverity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "severity", "body", int32(m.Severity)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateStartEpoch(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "startEpoch", "body", int64(m.StartEpoch)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateSubChainID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "subChainId", "body", int32(m.SubChainID)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateSuppressDesc(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "suppressDesc", "body", string(m.SuppressDesc)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateSuppressor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "suppressor", "body", string(m.Suppressor)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateTenant(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenant", "body", string(m.Tenant)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateThreshold(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "threshold", "body", string(m.Threshold)); err != nil {
		return err
	}

	return nil
}

func (m *AlertResponse) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AlertResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AlertResponse) UnmarshalBinary(b []byte) error {
	var res AlertResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
