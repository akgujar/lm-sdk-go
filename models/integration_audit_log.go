// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IntegrationAuditLog integration audit log
//
// swagger:model IntegrationAuditLog
type IntegrationAuditLog struct {

	// The id of the alert
	// Read Only: true
	AlertID string `json:"alertId,omitempty"`

	// The id of the alert instance
	// Read Only: true
	AlertInstanceID string `json:"alertInstanceId,omitempty"`

	// The type of the alert
	// Read Only: true
	AlertType int32 `json:"alertType,omitempty"`

	// Error message (if any) from ADC
	// Read Only: true
	ErrorMessage string `json:"errorMessage,omitempty"`

	// The parsed External Ticket ID from alert delivery
	// Read Only: true
	ExternalTicketID string `json:"externalTicketId,omitempty"`

	// When the delivery result was saved in LMES
	// Read Only: true
	HappenedOnMs int64 `json:"happenedOnMs,omitempty"`

	// HTTP request headers used in alert delivery
	// Read Only: true
	Headers string `json:"headers,omitempty"`

	// The HTTP Response Body received after alert delivery
	// Read Only: true
	HTTPResponse string `json:"httpResponse,omitempty"`

	// The HTTP Response Code received from 3rd party API
	// Read Only: true
	HTTPResponseCode int32 `json:"httpResponseCode,omitempty"`

	// The id of audit log record
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The Integration Alert Status used for delivery
	// Read Only: true
	IntegrationAlertStatus string `json:"integrationAlertStatus,omitempty"`

	// The name of integration
	// Read Only: true
	IntegrationName string `json:"integrationName,omitempty"`

	// The type of integration
	// Read Only: true
	IntegrationType string `json:"integrationType,omitempty"`

	// The number of times delivery was retried
	// Read Only: true
	NumRetries int32 `json:"numRetries,omitempty"`

	// The HTTP Request payload
	// Read Only: true
	Payload string `json:"payload,omitempty"`

	// The outbound payload format
	// Read Only: true
	PayloadFormat string `json:"payloadFormat,omitempty"`

	// The URL where the alert was delivered to
	// Read Only: true
	URL string `json:"url,omitempty"`
}

// Validate validates this integration audit log
func (m *IntegrationAuditLog) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this integration audit log based on the context it is used
func (m *IntegrationAuditLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAlertID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertInstanceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateErrorMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalTicketID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHappenedOnMs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeaders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHTTPResponse(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHTTPResponseCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIntegrationAlertStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIntegrationName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIntegrationType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNumRetries(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePayload(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePayloadFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IntegrationAuditLog) contextValidateAlertID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertId", "body", string(m.AlertID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateAlertInstanceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertInstanceId", "body", string(m.AlertInstanceID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateAlertType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertType", "body", int32(m.AlertType)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateErrorMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "errorMessage", "body", string(m.ErrorMessage)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateExternalTicketID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "externalTicketId", "body", string(m.ExternalTicketID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateHappenedOnMs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "happenedOnMs", "body", int64(m.HappenedOnMs)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateHeaders(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "headers", "body", string(m.Headers)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateHTTPResponse(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "httpResponse", "body", string(m.HTTPResponse)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateHTTPResponseCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "httpResponseCode", "body", int32(m.HTTPResponseCode)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateIntegrationAlertStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "integrationAlertStatus", "body", string(m.IntegrationAlertStatus)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateIntegrationName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "integrationName", "body", string(m.IntegrationName)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateIntegrationType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "integrationType", "body", string(m.IntegrationType)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateNumRetries(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "numRetries", "body", int32(m.NumRetries)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidatePayload(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "payload", "body", string(m.Payload)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidatePayloadFormat(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "payloadFormat", "body", string(m.PayloadFormat)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationAuditLog) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "url", "body", string(m.URL)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IntegrationAuditLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IntegrationAuditLog) UnmarshalBinary(b []byte) error {
	var res IntegrationAuditLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
