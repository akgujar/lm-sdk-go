// Code generated by go-swagger; DO NOT EDIT.

package client

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"strings"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/logicmonitor/lm-sdk-go/v3/client/lm"
)

const (
	// DefaultHost is the default Host
	// found in Meta (info) section of spec file
	DefaultHost string = "localhost"
	// DefaultBasePath is the default BasePath
	// found in Meta (info) section of spec file
	DefaultBasePath string = "/santaba/rest"
)

type TokenType int

const (
	LMv1AuthToken TokenType = iota
	BearerToken
)

// DefaultSchemes are the default schemes found in Meta (info) section of spec file
var DefaultSchemes = []string{"https"}

// Config information for LMSdkGo client
type Config struct {
	AccessKey    *string
	AccessID     *string
	TransportCfg *TransportConfig
	UserAgent    *string
	TokenType    TokenType
	BearerToken  *string
}

// NewConfig create a new empty client Config
func NewConfig() *Config {
	return &Config{
		TransportCfg: DefaultTransportConfig(),
	}
}

// SetTokenType for the client Config
func (c *Config) SetTokenType(tokenType TokenType) {
	c.TokenType = tokenType
}

// SetBearerToken for the client Config
func (c *Config) SetBearerToken(bearerToken *string) {
	if !strings.HasPrefix(*bearerToken, "Bearer ") {
		*bearerToken = "Bearer " + *bearerToken
	}
	c.BearerToken = bearerToken
	c.TokenType = BearerToken
}

// SetAccessID for the client Config
func (c *Config) SetAccessID(accessID *string) {
	c.AccessID = accessID
}

// SetAccessKey for the client Config
func (c *Config) SetAccessKey(accessKey *string) {
	c.AccessKey = accessKey
}

// SetUserAgent for the client Config
func (c *Config) SetUserAgent(userAgent string) {
	c.UserAgent = &userAgent
}

// SetAccountDomain for the client Config
func (c *Config) SetAccountDomain(accountDomain *string) {
	if c.TransportCfg == nil {
		c.TransportCfg = DefaultTransportConfig()
	}
	domain := *accountDomain
	c.TransportCfg = c.TransportCfg.WithHost(domain)
}

// New creates a new LM sdk go client
func New(c *Config) *LMSdkGo {
	transport := httptransport.New(c.TransportCfg.Host, c.TransportCfg.BasePath, c.TransportCfg.Schemes)

	defaultAccessKey := ""
	defaultAccessID := ""
	defaultBearerToken := ""
	defaultUserAgent := "Logicmonitor/GO-SDK"

	if c.AccessID == nil {
		c.AccessID = &defaultAccessID
	}
	if c.AccessKey == nil {
		c.AccessKey = &defaultAccessKey
	}
	if c.BearerToken == nil {
		c.BearerToken = &defaultBearerToken
	}
	if c.UserAgent == nil {
		c.UserAgent = &defaultUserAgent
	}

	authInfo := GetAuthInfo(c.TokenType, *c.AccessID, *c.AccessKey, *c.BearerToken, *c.UserAgent)

	cli := new(LMSdkGo)
	transport.Consumers["application/binary"] = LMBinaryFileConsumer()
	cli.Transport = transport

	cli.LM = lm.New(transport, strfmt.Default, authInfo)

	return cli
}

// DefaultTransportConfig creates a TransportConfig with the
// default settings taken from the meta section of the spec file.
func DefaultTransportConfig() *TransportConfig {
	return &TransportConfig{
		Host:     DefaultHost,
		BasePath: DefaultBasePath,
		Schemes:  DefaultSchemes,
	}
}

// TransportConfig contains the transport related info,
// found in the meta section of the spec file.
type TransportConfig struct {
	Host     string
	BasePath string
	Schemes  []string
}

// WithHost overrides the default host,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithHost(host string) *TransportConfig {
	cfg.Host = host
	return cfg
}

// WithBasePath overrides the default basePath,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithBasePath(basePath string) *TransportConfig {
	cfg.BasePath = basePath
	return cfg
}

// WithSchemes overrides the default schemes,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithSchemes(schemes []string) *TransportConfig {
	cfg.Schemes = schemes
	return cfg
}

// LMSdkGo is a client for LM sdk go
type LMSdkGo struct {
	LM *lm.Client

	Transport runtime.ClientTransport
}

// SetTransport changes the transport on the client and all its subresources
func (c *LMSdkGo) SetTransport(transport runtime.ClientTransport) {
	c.Transport = transport

	c.LM.SetTransport(transport)

}

func LMv1Auth(accessId, accessKey, userAgent string) runtime.ClientAuthInfoWriter {
	return runtime.ClientAuthInfoWriterFunc(func(r runtime.ClientRequest, _ strfmt.Registry) error {
		// get epoch
		now := time.Now()
		nanos := now.UnixNano()
		epoch := strconv.FormatInt(nanos/1000000, 10)

		// build the signature
		h := hmac.New(sha256.New, []byte(accessKey))
		h.Write([]byte(r.GetMethod() + epoch))

		if r.GetBodyParam() != nil {
			buf := new(bytes.Buffer)
			enc := json.NewEncoder(buf)
			enc.SetEscapeHTML(false)
			_ = enc.Encode(r.GetBodyParam())
			h.Write(buf.Bytes())
		}

		if r.GetFileParam() != nil {
			for _, files := range r.GetFileParam() {
				for i, file := range files {
					buf := bytes.NewBuffer(nil)
					buf.ReadFrom(file)
					h.Write(buf.Bytes())
					file = runtime.NamedReader(file.Name(), bytes.NewReader(buf.Bytes()))
					files[i] = file
				}
			}
		}

		h.Write([]byte(r.GetPath()))
		hexDigest := hex.EncodeToString(h.Sum(nil))
		signature := base64.StdEncoding.EncodeToString([]byte(hexDigest))
		r.SetHeaderParam("Authorization", fmt.Sprintf("LMv1 %s:%s:%s", accessId, signature, epoch))
		r.SetHeaderParam("User-Agent", fmt.Sprintf(userAgent))
		return r.SetHeaderParam("X-version", "3")
	})
}

func BearerAuth(bearerToken, userAgent string) runtime.ClientAuthInfoWriter {
	return runtime.ClientAuthInfoWriterFunc(func(r runtime.ClientRequest, _ strfmt.Registry) error {
		r.SetHeaderParam("Authorization", fmt.Sprintf(bearerToken))
		r.SetHeaderParam("User-Agent", fmt.Sprintf(userAgent))
		return r.SetHeaderParam("X-version", "3")
	})
}

func GetAuthInfo(tokenType TokenType, accessID, accessKey, bearerToken, userAgent string) runtime.ClientAuthInfoWriter {
	switch tokenType {
	case BearerToken:
		return BearerAuth(bearerToken, userAgent)
	case LMv1AuthToken:
		return LMv1Auth(accessID, accessKey, userAgent)
	default:
		return LMv1Auth(accessID, accessKey, userAgent)
	}
	return nil
}

func LMBinaryFileConsumer() runtime.Consumer {
	return runtime.ConsumerFunc(func(reader io.Reader, data interface{}) error {
		if reader == nil {
			return errors.New(1, "LMBinaryFileConsumer requires a reader", data) // early exit
		}
		buf := new(bytes.Buffer)
		_, err := buf.ReadFrom(reader)
		if err != nil {
			return err
		}
		b := buf.Bytes()
		w, ok := data.(io.Writer)
		if !ok {
			return errors.New(1, "provided output object is not of type io.writer", data)
			// the assertion failed.
		}
		_, err = w.Write(b)
		if err != nil {
			return err
		}
		c, ok := w.(interface{ Close() })
		if ok {
			c.Close()
		}
		return nil
	})
}
